{"pages":[],"posts":[{"title":"pipe-Linux","text":"使用管道操作符“|”可以把一个命令的标准输出传送到另一个命令的标准输入中，连续的|意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出，依次类推。 如下examples ps -ef|less ps 用于查看进程，less用于分页显示，这个命令是表示把ps的进程按分页展示 find . -name “*.bam”|xargs rm -rfv 首先查询在当前目录下匹配得上尾缀为.bam的文件，然后通过管道符传递给xargs中的命令rm，这样就可以批量删除，因为rm默认是不支持正则匹配的，所以可以通过这种方式来做到批量删除，同样，采用元字符也能达到一定的目的，如下 1rm -rf test-{1..100}.txt #可以删除test-1.txt test-2.txt .... test-100.txt等一系列文件，这也是批量删除。 补充xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如： 12find /sbin -perm +700 |ls -l #这个命令是错误的find /sbin -perm +700 |xargs ls -l #这样才是正确的","link":"/2019/11/09/Linux/pipe/"},{"title":"symbolic-hard_link","text":"在Linux的应用当中，掌握软硬链接的方法很重要，学会软硬链接可以让我们更方便的使用Linux系统中的文件，特别是以项目的方式去管理文件时，可以在单个项目之内创建软硬链接，而在其他的项目当中也可以创建同样的软硬链接指向同样的脚本、软件等，这样子可以实现文件个高效复用，既能便捷实用，又能避免重复造轮子。 1. 硬链接 hard link创建方法： 1ln -d dir1/source_file dir2/hard-link_file 理解： 在Linux系统之中，文件储存在某一些储存空间上，删除文件的方式其实就是把对应的索引链接都删除就可以了，那么这一片空间就没有索引来访问了，那么这样就相当于是删除了文件，下次写文件的时候就会新建对应的索引链接，然后直接开始写入文件到储存空间，实现覆盖。 对于硬链接来说，就是创建一个新的索引，和原来文件的索引同级（原文件索引即原文件的名字），相当于是给文件创建了一个新的名字，但是没有创建新的文件，当原文件的索引被删除时，不会影响到硬链接，仍然可以通过硬链接访问文件，并且进行编辑。 如果需要彻底删除文件，那就意味着必须把所有的硬链接都删除掉，这样才是真正的删除，系统文件才无法找到这片空间中的原文件。 硬链接有点像是到一座小岛上的另一座桥，和原来通往这座岛的桥一样，都连接着同样的一个小岛，所以并没有创建新的文件，但是却多了一个保障，一旦原来的桥塌了（误删），仍然可以通过这座桥登上小岛。而不管通过哪座桥登上小岛进行建设规划，都会直接改动小岛真实的面目。 2. 软连接 symbolic link创建方法： 1ln -s dir1/souce_file dir2/symbolic_link 理解 软连接是真正的快捷方式既视感。软连接是一个文件，这个文件的内容是原文件的储存路径之类的，但是也只有这些，并没有原文件的具体内容，所以只是一个快捷方式，通过这个快捷方式可以快速的访问到文件，并进行使用。 因此，当在删除了原文件后，软连接就失效了，无法再访问原文件。 同样是用小岛来打比方，软连接就像是路标，指明了哪里有桥可以上岛，对于具体的小岛来说，软连接就指向了原来那座桥所在的方位，所以可以很快的找到桥然后上岛。所以拆掉路标不会影响桥的存在，但是一旦把桥拆了，那么路标也就没有用了，小岛已经再也上不去了，相当于在世界上消失了。 3. 软硬链接的区别 硬链接 hard link 软链接 symbolic link 不能给目录创建硬链接 可以给目录创建软链接 不能跨文件系统创建链接 可以跨文件系统创建软链接 文件的新索引，和原文件名互为别名 新文件，保存原文件路径，相当于快捷方式 不能给不存在的文件创建硬链接，因为硬链接存在即表示原文件存在，而不存在的文件就表示没有文件，也就没有链接可言。 可以给不存在的文件创建链接，因为路标可以随便建，有没有效无所谓，反正可以建。 4. ln 命令使用方法：” ln [options] 目标 “ 参数如下 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程 5. 实践 硬链接 hard link 软链接 symbolic link","link":"/2019/11/03/Linux/symbolic-hard-link/"},{"title":"working_with_files","text":"在Linux中，有着处理文本的三大常用的、非常强大的工具——awk/grep/sed，其中awk是报告生成工具，适合处理列数据；grep是文本过滤搜索工具；sed是文本编辑工具，完成一般的编辑工作。接下来我将学习如何使用这3个工具。PS：这三个工具操作的文本都可以通过重定向的方式输出到新文件中保存下来。 1. 预备内容 在正式学习这三个工具之前，先来了解一下Linux中的正则表达式。 在Linux中可以通过正则的方式对文本进行匹配处理，这就相当于是一个通用模板，awk、grep和sed都可以识别这套模板，相当于正则表达式可以成为这3个工具的拓展模板，通过结合正则，让这3个工具更加强大。 1.1. 正则的组成 元字符 功能 意思 ^ 匹配行首 表示以某个字符开头 $ 匹配行尾 表示以某个字符结尾 ^$ 空行的意思 表示空行的意思 . 匹配任意单个字符 表示任意一个字符 * 字符* 匹配0或多个此字符 示重复的任意多个字 |屏蔽一个元字符的特殊含义 表示去掉有意义的元字符的含 [] 匹配中括号内的字符 表示过滤括号内的字符 .* 代表任意多个字符 就是代表任意多个字符 以上就是常见的元字符，正则还有一些其他字符，如下图 2. awk使用使用文档如下： 3. grep使用使用文档如下： 4. sed使用使用文档如下：","link":"/2019/10/31/Linux/working-with-files/"},{"title":"Machine-learning mind map","text":"最近总是会忘记一些概念，对于机器学习的框架有些混淆模糊了，所以做了一个思维导图帮助理清框架，以期学习时有的放矢。 1. 什么是机器学习？ 机器学习是通过编程让计算机从数据中进行学习的科学和艺术。充分利用这些技术可以极大的提高人类生产的效率，是新一代的技术革命。 2. 为什么要用机器学习方法呢？ 原因如下： 需要进行大量手工调整或需要拥有长串规则才能解决的问题：机器学习算法通常可以简化代码、提高性能。 问题复杂，传统方法难以解决：最好的机器学习方法可以找到解决方案。 环境有波动：机器学习算法可以适应新数据。 洞察复杂问题和大量数据","link":"/2019/11/18/Machinelearning/Machine-learning/"},{"title":"ANOVA","text":"前言方差分析（analysis of variance）是在概率与统计学中很重要的一部分内容，方差分析用于检验多对数据的平均数差之间的显著性，如果是采用t检验的话，只能每次对2组数据进行检验，对于n组数据则需要进行2的排列组合次，并且即使每次的置信度为95%，累乘起来的置信度也不高，即容易犯错，所以需要新方法，方差分析就是解决这个问题的方法。在这一篇博客中我们只讨论单因素方差分析。 1. 基本概念 概念 理解 因素 在实验设计中，控制某个变量，如温度、光照、反应物浓度等等，这就是某个因素 水平 在因素的基础上，进一步选择一些度量，比如具体的温度梯度，每一个梯度就是一个水平 注意：在水平下还有多次重复样本，同一个水平中的方差称为组内方差，不同水平之间的方差称为组间方差，这是在稍后进行方差分解计算的基础。 2. 方差分析基本流程 收集所有待处理数据，提出原假设 计算数据的各项参数，进行方差分解 进行自由度分解 计算均方差，检验随机误差的方差与处理效应的方差的显著性 根据F检验判断是否具有显著性，得出结论 3. 两种效应计算 在处理效应中，具有固定效应和随机效应，固定效应指的的在实际的因素中指定特定的几个水平进行计算，得出的结论只适用于这几个水平，不能推广到所有水平，此时这个因素也可称为固定因素，相应的处理效应为固定效应；随机效应指的是把所有水平当做一个总体分布，从中随机抽取一些水平进行计算，此时这个因素也可以称为随机因素，相应的效应为随机效应，得到的结论可以推广到所有水平中使用。 符号说明： $$y_{i}.=\\sum_{j=1}^ny_{ij}$$ $$\\bar y_i.=\\frac1ny_i.\\ (i=1,2,3,…,a)$$ $$y..=\\sum_{i=1}^a\\sum_{j=1}^ny_{ij},\\ \\bar y..=\\frac1{an}y..$$ 3.1. 固定效应","link":"/2019/11/15/Mathematics/ANOVA/"},{"title":"linear-algebra","text":"I am going to share some experiences in the process that I study the linear Algebra, it is really excited that I just find a super nice textbook named Linear Algebra and the Applications. I really recommend it if you are going to study the linear algebra especially when you are mindless in which book that you should read. Life tips: Never judge others by your value, learn to accept the diversity, this is what the world looks like. Respect each other! Chapter 1 线性方程组content: 1.1. 线性方程组 1.2. 行化简与阶梯型矩阵 1.3. 向量方程 1.4. 矩阵方程 Ax=b 1.5. 线性方程组的解集 1.6. 线性方程组的应用 1.7. 线性无关 1.8. 线性变换介绍 1.9. 线性变换的矩阵 1.10. 商业、科学和工程中的线性模型","link":"/2019/11/07/Mathematics/linear-algebra/"},{"title":"概率统计","text":"概率论与数理统计是一门很重要的基础数学课，现在的机器学习的基础之一。现在这里添加的是这门学科的总览图，后期可能会做进一步的详细笔记。 总结概率论与数理统计这门学科的内容是具有继承性的。首先先讨论概率论，概率论的发展成为了数理统计的基础，特别是当大数定律和中心极限定理提出以后，数理统计变得有理论基础，开始快速发展，而在数理统计发展起来后，在应用方面，除了假设检验，方差分析和回归分析都是很重要的应用，对于我们建立模型有很大的帮助，是我们探寻变量关系的基础。","link":"/2019/11/04/Mathematics/概率统计/"},{"title":"Poetry Of Life","text":"这是生活中最甜美的一首诗！ 生活中遇到的每个人都是一部独一无二的书，每一本书都需要真心坦诚的读才可能会有所感悟。我的生活也是一本书，在我的书里，我希望她会是一首优美、独特的诗篇，在我读到她的诗句时，便能觉得生活是甜的！","link":"/2019/08/14/Poetry with Life/Lovelygirl/"},{"title":"从前慢","text":"从前慢—-木心记得早些少年时大家诚诚恳恳说一句 是一句 清早上火车站长街黑暗无行人卖豆浆的小店冒着热气 从前的日色变得慢车，马，邮件都慢一生只够爱一个人 从前的锁也好看钥匙精美有样子你锁了 人家就懂了","link":"/2019/07/28/Poetry with Life/从前慢/"},{"title":"以梦为马","text":"——海子从明天起，做一个幸福的人喂马、劈柴，周游世界 从明天起，关心粮食和蔬菜我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信 告诉他们我的幸福 那幸福的闪电告诉我的我将告诉每一个人 给每一条河每一座山取一个温暖的名字陌生人，我也为你祝福 愿你有一个灿烂的前程 愿你有情人终成眷属 愿你在尘世获得幸福 我只愿面朝大海，春暖花开 “从明天起，做一个幸福的人”，多么美好的诗句呀，做一个幸福的人，这应该是每一个人的梦想，但是在生活的洪流里面，多数人都为了生存而疲于奔波，连生存都困难，又怎么谈得上幸福呢，但是生活总是不只有眼前的苟且，还有诗和远方，我们总是会有千千万万的理由牵绊着我们去拥抱幸福，有时候拿起来很需要勇气，但是有时候放下更需要勇气，或许有一天，我们能够放下牵绊自己的理由，下定决心，从明天起，做一个幸福的人，安静的品味自己的生活，也不枉来人间走一遭。从明天起，开始悉心的感受生活，从观察开始，发现生活中以前不曾注意的细节，说不定，生活会开始变得不一样。","link":"/2019/08/29/Poetry with Life/以梦为马/"},{"title":"偶然","text":"偶然—-徐志摩 我是天空里的一片云， 偶尔投影在你的波心。 你不必讶异，更无须欢喜， 在转瞬间消灭了踪影。 你我相逢在黑夜的海上， 你有你的，我有我的，方向； 你记得也好，最好你忘掉， 在这交会时互放的光亮！ 我是一片云，曾走近你的心，但是我是云，远隔万里，随风而动，最终，又飘离了你的心，不奢求天长地久、海枯石烂，但是至少曾经美好的爱过，所以你我不必为此惆怅难过，我们曾经一起度过一段最美好的时光，这是你我回忆里的光辉，你若记得，那也好，但是，你最好忘了吧，从现在开始拥抱着你的新生活，不用担心这份美好会在时光的长河里淹没，因为我一直铭记心中，不曾丝毫遗忘褪色。 这首诗是徐志摩与林徽因在欧洲别离又在国内相遇时作的诗。徐志摩与林徽因曾经是恋人，但是再次相遇时，林徽因已经嫁给梁思成为人妻了，正所谓“物是人非事事休，未语泪先流。”，不过虽然如此，徐志摩还是写下了这首诗送给了林徽因。","link":"/2019/09/05/Poetry with Life/偶然/"},{"title":"再别康桥","text":"—-徐志摩 轻轻的我走了，正如我轻轻的来；我轻轻的招手，作别西天的云彩。那河畔的金柳，是夕阳中的新娘；波光里的艳影，在我的心头荡漾。软泥上的青荇，油油的在水底招摇；在康河的柔波里，我甘心做一条水草！那榆阴下的一潭，不是清泉，是天上虹；揉碎在浮藻间，沉淀着彩虹似的梦。寻梦？撑一支长蒿，向青草更青处漫溯；载满一船星辉，在星辉斑斓里放歌。但是我不能放歌，悄悄是别离的笙箫；夏虫也为我沉默，沉默是今晚的康桥！悄悄的我走了，正如我悄悄的来；我挥一挥衣袖，不带走一片云彩。 初次读到徐志摩的这一首诗是在初中，兴许早在很久之前就听闻过 “我挥一挥衣袖，不带走一片云彩。” 这些诗句了。时隔多年，再读 《再别康桥》 ，品味到一种当初无法体会到的美感。整首诗读起来一气呵成，感情犹如潺潺溪水，绵延不绝，柔情仿佛就是轻柔的月光，一下子倾泻而出，别离之情即真挚热烈，又温柔似水，诗情画意，尤为动人，真不愧是诗词才子。","link":"/2019/09/25/Poetry with Life/再别康桥/"},{"title":"初相遇","text":"—-席慕蓉 美丽的诗和美丽的梦一样 都是可遇不可求的 常常在最没料的时刻里出现 我喜欢那样的梦 在梦里，一切都可以重新开始 一切都可以慢慢解释 心里甚至还能感觉到所有被浪费的时光 竟然能够重回时的狂喜和感激 胸怀中满溢着幸福 只因为你就在我眼前 对我微笑 一如当年 我真喜欢那样的梦 明明知道你已为我跋涉千里 却又觉得芳草鲜美 落英缤纷 好像你我才初相遇 >第一次相遇，或许未曾察觉到你我之间将会有一段美好的故事，就像是无数的其他平凡的相遇——相遇 擦肩 遗忘，但这不是你我的剧本，我们会有不一样的邂逅，然后铭记彼此。也许在许多年以后，我们已经走进了生活的五光十色里，彼此再相遇，这一次，我们是否会像初相遇时，再一次目光相遇，便已察觉到，我们故事——未完待续。","link":"/2019/09/13/Poetry with Life/初相遇/"},{"title":"半截的诗","text":"—-海子 你是我的半截的诗，不许别人更改一个字。 简单的一句诗，却颇有一种浪漫从字里行间迸发而出，这爱热情似火，纵世界五彩缤纷，我只宠你一人；这爱始终如一，矢志不渝，你就是我的生命的另一半，我不允许别人改变你，这爱有点任性，对你，不曾更改；这爱是不言的浪漫，希望纸短情长，一句 两句，都能写进你的心坎。","link":"/2019/09/17/Poetry with Life/半截的诗/"},{"title":"发呆","text":"发呆—-我站在阳台向下看风抚着白千层的枝条摇曳阳光洒在阳台的仙人掌上金色的绒毛，像极了 发呆只有耳边的旋律冬日的阳光慵懒着，宠溺不想动只愿被光融化了飘散到小草 大树 行人身上留下一丝温热那就好了 这是在刚入大学时候，在宿舍写得诗，是的，这是一首诗，是我生活的诗，它看起来不美，但是足够敲打我的心弦。有时候，真感激当初的自己，在奔涌向前的时光流水里，留下了一只小纸船，让我能够在今后的某一天，回头时，能窥见自己当初的样貌。以前看着真傻，看着真好。","link":"/2019/07/28/Poetry with Life/发呆/"},{"title":"夏天的太阳","text":"夏天的太阳—-海子活在这珍贵的人间太阳强烈水波温柔一层层白云覆盖着我踩在青草上感到自己是彻底干净的黑土块活在这珍贵的人间 泥土高溅扑打面颊活在这珍贵的人间人类和植物一样幸福爱情和雨水一样幸福 在读过木心、汪国真的诗后，和海子的诗对比，木心先生的诗显得淡雅精致，读起来就像是在品一杯淡茶；汪国真的诗韵律巧妙，读起来就像是一首歌曲，抑扬顿挫。木心先生和汪国真先生也写感情，木心先生淡雅，汪国真先生则是直抒胸臆。看海子的诗，有种虽然没有木心先生的淡雅滋味，但是也不会像汪国真先生的开门见山，独有一份自己感受生活、抒发感情的态度与章法，可以说，我可能更喜欢海子的诗词，一种我能够品尝到，但是又不至于像汪国真先生诗词那样浓郁的爱意。另外，海子的诗应该更多的是对生活细节的体验，像一个可以触及的平常人，显得真实，但是在海子的笔触下又能写的出让人心血澎湃的感人诗句，平常之中孕育着不凡的灵魂。","link":"/2019/08/30/Poetry with Life/夏天的太阳/"},{"title":"怀想","text":"---汪国真 我不知道 是否 还在爱你 如果爱着 为什么 会有那样一次分离 我不知道 是否 早已不再爱你 如果不爱 为什么记忆没有随着时光 流去 回想你的笑靥 我的心 起伏难平 可恨一切 都已成为过去 只有婆娑的夜晚 一如从前 那样美丽","link":"/2019/08/14/Poetry with Life/怀想/"},{"title":"思念","text":"思念—-汪国真我叮咛你的你说不会遗忘你告诉我的我也全都珍藏对于我们来说记忆是飘不落的日子——永远不会发黄 相聚的时候总是很短期待的时候总是很长岁月的溪水边捡拾起多少闪亮的诗行如果你要想念我就望一望天上那闪烁的繁星有我寻觅你的目——光 “我叮咛你的 你说不会遗忘 你告诉我的 我也全都珍藏” 相遇、相知、相恋，这是一个多么美妙的过程呀，你我之间的互动，充满了恋人之间的不用言说的默契，只是一个眼神相遇，那便是千言万语，在彼此心里浮现，这就是恋人间所谓的心有灵犀吧！“记忆是飘不落的日子 永远不会发黄”，这一句里用了暗喻的手法，把记忆与叶子相互比喻，记忆不飘落，永远在树上，那便是常青于树上，所以不会发黄，也就是不会遗忘。说到这里，美好记忆永存也是很多人的共同愿望，但是，会不会永存呢？时间会告诉我们答案。","link":"/2019/08/01/Poetry with Life/思念/"},{"title":"我想和你虚度时光","text":"我想和你虚度时光—-李元胜我想和你虚度时光，比如低头看鱼比如把茶杯留在桌子上，离开浪费它们好看的阴影我还想连落日一起浪费，比如散步一直消磨到星光满天我还要浪费风起的时候 坐在走廊发呆，直到你眼中的乌云全部被吹到窗外我已经虚度了世界，它经过我疲惫，又像从未被爱过但是明天我还要这样，虚度满目的花草，生活应该像它们一样美好一样无意义，像被虚度的电影那些绝望的爱和赴死为我们带来短暂的沉默我想和你互相浪费 读到这首诗的时候，闭上眼，仿佛能够感受到阳光烘焙着空气的留下的淡淡暖意，空气中弥漫着一种慵懒的气息。她坐在窗边，头枕着手趴在桌子上，我坐在对面，安静的看着她，就是安静的看着，听着彼此的呼吸声、心跳声，不说话，然后目光相遇、对视、凝望，柔情暖意似水般涌动跳跃，此时墙壁上的挂钟滴答滴答的规律的跳动着，时间从指缝间溜走，就这么溜走，心甘情愿的让它跑了。我们就是这么对视着，不说话，但又好像说了很多话，一直在说话","link":"/2019/07/28/Poetry with Life/我想和你虚度时光/"},{"title":"是否","text":"——汪国真是否 你已把我遗忘不然为何 杳无音信天各一方是否 你已把我珍藏不然为何 微笑总在装饰我的梦 留下绮丽的幻想 是否 我们有缘 只是源头水尾 难以相见 是否 我们无缘 岁月留给我的将是 愁绪萦怀 寸断肝肠 汪国真的这首诗情人相隔远方，思念无法排遣的愁绪填满了字里行间，当诗句一句句映入脑海，似乎能够看见那相思柔情，这等柔情是凄美的，也是许多人所经历的，我虽然觉得诗词美，但终究是写的露骨，少些含蓄，在这一方面有所考究的话，或许能更符合我的喜好。“问世间情为何物，直教人生死相许”，难呀！ 今天重新部署了一下博客，换成了在Windows中写，这样就不用登录服务器了，而且还尝试了hexo-admin这个插件，可以直接在网页上写博文，现在先试试效果怎们样，测试一下！","link":"/2019/08/26/Poetry with Life/是否/"},{"title":"暮色","text":"—-席慕蓉 在一个年轻的夜里 听过一首歌 清冽 缠绵 如山风拂过百合 再渴望时 却声息寂灭 不见踪迹 亦无来处 空留那月光沁人肌肤 而在而十年后的一个黄昏里 有什么是与那夜相似 进而使那旋律翩然来临 山鸣谷应 直逼我心 回顾所来径啊 苍苍横着的翠微 这半生的坎坷啊 在暮色中 竟化为甜蜜的热泪 >青春易逝，当人至暮年，回首数十年前的风华正茂，不知道是什么感想，从席慕蓉的诗来看，似乎每当暮年回顾年轻的夜总是甜的，令人感叹的，值得珍惜的，可能也是这样的，在人文主义的角度看来，人的体验是神圣的，这是人生命意义的来源，因此不管在年少时经历过什么风雨，当人至暮年，即将走向生命的终点站的时候，这一切都是这一生意义的来源，都应该是值得感悟的经历。在这样一个年纪，伴随着荷尔蒙的分泌，或是激情四射，或是思绪萦绕，这一切都是青春的味道，这样的味道是值得人去铭记一生的，值得人去反复品味的。这让我想起了《钢铁是怎么炼成的》里的一段话，当人至暮年时，你会怎么看待你的人生呢？怎样的人生才能够让你无悔呢？才能够让你觉得没有白来人间走一遭呢？这是个值得思考的问题，我仍需多思考思考。","link":"/2019/09/14/Poetry with Life/暮色/"},{"title":"哪有你这样你","text":"哪有你这样你—-木心十五年前阴凉的晨 恍恍惚惚清晰的诀别 每夜，梦中的你梦中是你 与枕俱醒觉得不是你 另一些人扮演你入我梦中 哪有你，你这样好哪有你这样你","link":"/2019/07/27/Poetry with Life/机器学习名词解释/"},{"title":"爱情是棵树","text":"爱情是棵树—-木心我是锯子上行 你是锯子下行 合把那树锯断两边都可见年轮一堆清香的屑锯断了才知爱情是棵树树已很大了 第一次读到这首诗的时候，是大一了，不过并没有读懂，直到现在也没有读懂，倒是颇为好奇，这拿锯子锯树的方式到底是两个人拉着一把锯子，上下行的合作锯树呢，还是，两个人各拿着一把锯子，在树的两侧锯着，这两种方式都符合诗中的描述，所以我确实有些疑惑，不知道是哪种理解好，如果是第一种，倒是比较好理解，两人共同生活，共同为爱情负责嘛，力总是相互的，所以锯子一来一去，树倒了不是个人的责任，两者都是要负责的。但是，如果是第二种状况，那就可能是一方快些、多些，另一方慢些、少些，毕竟两把锯子，说以完全一样，那是不实际的。所以这个疑惑让我有些难以理解诗，不过，这个关注点确实有点剑走偏锋了。","link":"/2019/08/01/Poetry with Life/爱情是棵树/"},{"title":"陪伴","text":"陪伴我一辈子走过许多地方的路，行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。 —-沈从文 这是在今天出门随意走走时看到的一幅画面，两个耄耋老人随步履蹒跚，但却互相依靠、陪伴，这不禁让我心中涌起一股暖意，正如沈从文先生所说，一生只爱过一个正当最好年龄的人，一生之爱，一生陪伴，或许老人们并不曾谈及爱情，但是相濡以沫之情充溢着画幅，陪伴是最长情的告白！","link":"/2019/08/09/Poetry with Life/陪伴/"},{"title":"404problem","text":"在8月28日晚，也就是昨晚，在更新了一些_config.yml里面的内容后，输入hexo clean &amp;&amp; hexo g &amp;&amp; hexo d指令后，出现了页面404，不管是刷新还是改其他信息，都无法解决这个问题，在看了网上很多相关博客后也没有找到问题的根源，最终还是在仔细看了GitHub的404页面的提醒，如下图 才发现，原来是GitHub的page的repository的根目录里没有了index.html文件，导致在访问https://genening.github.io时GitHub无法找到静态网页的文件，所以显示不出来，跳转到了404页面找到了问题所在之后，我就开始想办法解决了。先是查看了另外一个网站—— https://193.148.16.42的根目录的index.html文件，看看里面的内容应该是什么，然后再查看了整个目录的结构，对比我部署到GitHub的repository里面的文件目录结构，发现有很多不同，如果自己从头做一份的话很麻烦，而且hexo博客应该会自动生成，怎么会没有了呢，于是我就重新运行了一遍hew new &quot;blogname&quot;，发现hexo博客又重新生成了一遍目录，这一次目录结构就和另一份博客的目录一致了，于是我紧接着hexo clean &amp;&amp; hexo g &amp;&amp; hexo d一遍，发现GitHub上面的目录又更新了，再次访问，就能显示正常的blog页面了。具体产生这个问题的原因还不知道，不过也算是吃一堑长一智了，下次注意一些就好，而且也找到了解决问题的思路，也算是花费了我半天时间找解决办法的收获吧。故写此博客用以记录。","link":"/2019/08/29/log/404problem/"},{"title":"Markdown学习笔记","text":"Introduction 接下来我将会以简单明了的方式介绍Markdown的语法，介绍的过程也是我学习实践的过程，这也是我第一次全文用Markdown语法书写文章，还很生疏，有些语法可能也还不太了解，所以会有翻车的现象。 Markdown 由 John Gruber 在2004年创建，至今已经是12年的时间。这门语言的宗旨是易读易写，而它的语法也确实如此，简单强大！接下来开始学习！ 基本写作1. 标题标题分为6级，如下 #一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 效果如下 一级标题二级标题三级标题四级标题五级标题六级标题 2.强调 斜体—包括在两个 ‘’或‘_’ 之间的字符*黑体—包括在两个‘’或‘__’之间的字符删除线—包括在两个‘~~’之间的字符全部复合使用（有待补充） 3.列表 无序列表 苹果 香蕉有序列表 苹果 香蕉 4.引用引用如下 这里面是引用的内容，通过在段前添加‘&gt;’符号开始引用段落，在此段后空一行即结束引用，在段落间使用 这是嵌套引用 这也是 5.代码 print 'Hello world' 在两个反引号‘`’之间为行内代码 12def function(x): return x^2 在连用三个反引号‘`’之间的符号为代码区块，如上所示 6.分割线 如下（连续三个或以上‘*’），即表示分割线 或者如下（空一行，连续三个或以上‘-’） 7.表格通过如下方式可以渲染出表格 12345|table|head|here||:-----|:-----:|-----:||content1|content2|content3||content1|content2|content3||content1|content2|content3| 效果如下 table head here content1 content2 content3 content1 content2 content3 content1 content2 content3 ### 8.图片 ![Von Gogh](./Markdown简易教程/Von_Gogh.jpg) 就是上面这段格式的代码就是引用了这张梵高的图片了，注意的是其中的图片的地址，这个是同级目录下的直接引用，属于相对目录，也可以用绝对路径，不管相对还是绝对，路径一定要准确，这样才能定位到需要引用的图片上，才能展示出来 9.链接 链接就是比上面的图片的引用少了前面的‘！’，去掉这个感叹号后，再把需要的链接URL放在后面的括号里就可以了[My github page site](https://genening.github.io) My github page site或者百度首页 10.公式 公式的展示是采用LaTeX的语法，通过这个网站可以把公式对应的LaTeX的写法转换出来 如下为行内公式 $E=mc^2$对应 $E=mc^2$ 有待尝试 如下为公式块 1234$$e^{i\\theta} = \\cos \\theta +i\\sin \\theta \\e^z = 1 + \\frac{z}{1!} + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\cdots = \\sum_{n=0}^{\\infty}\\frac{z^n}{n!}$$ 效果出不来，比较尴尬 11.反斜线 如果想插入一些特殊字符的话需要转义符号反斜线‘\\’，引入这个反斜线后，就可以使用上面的那些特殊的字符了，这样不会触发对应的渲染效果 \\反斜线`反引号*星号_底线{}花括号如上符号等等 12.脚注脚注可以用于编辑参考文献 在文中使用[^1]的方式标记脚注 在文末使用[^1]:加入参考文献，注意要使用英文冒号，后面有无空格均可 效果如此[^1]，或者是参考文献[^1]: 此处尝试又出bug了，接着完善 结语Markdown是所谓的轻量标记语言(lightweight markup language)，它可以让我们在写文章的时候专注于写作本身，而不用费心于排版，这种思想和LaTeX的思想不谋而合。现在很多网站都支持Markdown，也有很多相应的编辑软件，例如Typora，这是个很好用的Markdown的编辑软件。另外，让Markdown更强大的是，Markdown支持直接插入HTML的语法，也能插入LaTeX的语法，这样的扩展能力，让Markdown即满足了轻便易用的基础上，进一步增强了能力，这也是Markdown现在炙手可热的原因之一。","link":"/2019/08/29/log/Markdown学习笔记/"},{"title":"firstblog","text":"hello world, this is my first blog, I do not know if this blog can work, so I just have a try.It seems like work perfectly, okay, let is begain our new way of life.","link":"/2019/07/27/log/firstblog/"},{"title":"hexo博客写作流程","text":"这篇文章的目的是为本博客的博文作者提供指导，介绍需要准备的工具、写作流程和发布方法。查看 Hexo 文档 了解关于博客框架的详细内容。 依赖 博文作者 nodejs - Hexo 基础 npm - Node.js 包管理器 hexo-cli - Hexo 博客框架 git - 版本控制系统 服务器 git - 版本控制系统 nginx - Web服务器 准备工作Hexo 是静态博客框架，因此每个页面在读者访问之前就已经被渲染完成，大部分的工作都落在博文作者处。Hexo 依赖 Node.js 运行时环境工作，请访问 nodejs.org 或使用包管理器获取 Node.js，同时安装其包管理器 npm。随后即可使用 npm 安装 Hexo，建议设置为全局安装： 1$ npm install -g hexo-cli 想起来了就升级一下所有包，获取安全和功能更新： 1$ npm update -g 为方便部署，我们使用 git 执行版本控制，访问 git-scm 或使用包管理器安装 git。博客的配置和源文件仓库都保存在服务器上，要同步不同作者的更改或从新环境开始，可 merge 或 clone 博客仓库以得到工作区。 Hexo 使用 Markdown 创作博文，因此建议使用带有 Markdowm 预览的编辑器。准备工作结束之后，就能开始愉快地写作了。 流程 新建页面 1$ hexo new [layout] [option] &lt;title&gt; 在制定布局的基础上新建文章，可用选项有 Option Description -p, --path 自定义文章路径 -r, --replace 覆盖指定博文 -s, --slug 自定义文章URL 写博文 使用 Markdown 撰写文章，但不限于 Markdown 的语法。可以使用 HTML 元素实现更灵活的布局，同时通过 Hexo 插件得到例如资源文件夹管理等更强大的功能。 博客写作的高级功能包括： MathJax 数学公式支持 使用 $ LaTex $ 插入行内公式，$$ LaTex $$ 插入行间公式。 资源文件夹管理 资源文件夹管理是成为正式组件的社区插件之一，在需要插入图片的地方使用一下格式引用资源文件夹 JavaScript1{% asset_img 文件名 文件描述 %} 插入页面目录 在 Front-matter 中指定 1toc: true Hexo 将在指定位置渲染页面目录，方便长文章的浏览。 发布 写作完成后，使用以下命令发布到服务器： 1$ hexo g -d 这会让 Hexo 渲染所有页面，并使用 git 将网页文件推送至远程的 publish 分支。在服务器上，git hooks 会在接收推送后自动将其复制到 nginx 的根目录，可以立即在博客上查看更改。 注意直接部署并不会推送博客配置文件以及文章源文件，要备份整个工作区，请手动推送 master 分支到服务器，这个过程与部署过程相独立。","link":"/2019/08/29/log/博客写作流程/"},{"title":"Electron","text":"简介 Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。简单来说，这是一个强大的工具，可以用于搭建跨平台桌面应用，而且有方便强大的API库提供，所以，开始一场新的探索吧，如果你永远只做你能做到的事情，那么你永远也只能停在当前的高度。 目录：暂略1. 环境准备 安装Node.js Node.js下载页面 npm 安装Node.js的时候已经安装了 检查npm node是否安装成功，在命令行工具中输入node -v npm -v，显示版本号则便是环境准备完成。就是这么简单，赶紧尝试一下吧！ 快速开始一个项目 12345678# 克隆示例项目的仓库$ git clone https://github.com/electron/electron-quick-start# 进入这个仓库$ cd electron-quick-start# 安装依赖并运行$ npm install &amp;&amp; npm start 效果如下： 这个quick-start项目提供了一个非常简约的模板，可以在这个基础上搭建自己的应用。看起来还是不错的，很期待打包成桌面应用的效果。 quick-start目录解析 node_modules：模块依赖 package.json：描述包的文件，这里默认已经将主进程入口文件配置为main.js main.js：主进程 renderer.js：渲染进程，它的操作跟web中的js操作大同小异，所以最好有node.js、js以及es6的语法的功底，这样开发起来，才能得心应手。","link":"/2019/11/08/web/Electron/"},{"title":"JS学习笔记","text":"第一部分：JS介绍及基础知识 目录 初识JavaScript 变量和常量的知识 基本数据类型 运算符 基本数据类型间的转换 流程控制语句 1. 初识JavaScript概述： JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 javascript组成 （1）ECMAScript，描述了该语言的语法和基本对象。（2）文档对象模型（DOM），描述处理网页内容的方法和接口。（3）浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 应用 （1）嵌入动态文本于HTML页面。（2）对浏览器事件做出响应。（3）读写HTML元素。（4）在数据被提交到服务器之前验证数据。（5）检测访客的浏览器信息。 （6）控制cookies，包括创建和修改等。（7）基于Node.js技术进行服务器端编程。 2. 变量与常量认识引入 javascript的引入有三种方式:（1）写在标签内（2）使用&lt;script&gt;&lt;/script&gt;标签（3）独立js文件，使用link引入 123456789101112标签内&lt;style type=\"text/css\"&gt; #div {background-color:red;} //#是id标签 .p {color:blue;} //'.'是class类标签&lt;/style&gt;script标签&lt;scipt tpye=\"text/javascript\"&gt;js语句&lt;/script&gt;引入&lt;script src=\"\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;link href=\"https://...\" rel=\"stylesheet\"&gt; 标识符与关键字 第二部分：jsDOM操作 目录 属性、文本操作 css操作 对象与数组 面向对象编程","link":"/2019/09/07/web/JS学习笔记/"},{"title":"无参转录组分析","text":"这是一篇关于使用Trinity进行无参转录组分析的文章，首先会简单介绍转录组学，接着会介绍Trinity软件的使用，最后会记录相关的下游分析 一、转录组学概述： 转录组广义上指在某一生理条件下，细胞内所有转录组产物的集合，包括：mRNA、ncRNA、rRNA等；狭义上指所有mRNA的集合。 转录组测序的研究对象为特定细胞在某一功能状态下所能转录出来的所有RNA的总和，主要包括mRNA和ncRNA。 转录组具有时间特异性、组织特异性、空间特异性等特点。 类型 特点 分析策略 有参转录组 需要所研究的物种有组装注释质量较好基因组序列，一般来说比对效率达到70%以上才能满足后续分析。 比对—定量—差异分析—功能富集分析（下游分析） 无参转录组 缺乏相应的质量较高的基因信息，需要从零开始组装分析 组装—定量—差异分析—功能富集分析（下游分析） 下游分析包括：GO基因功能注释、KEGG通路分析、mRNA表达量计算、差异基因筛选、功能和通路富集分析、时间序列分析、共表达网络分析等 二、Trinity介绍与使用基本介绍 是由Broad Institute 开发的转录组de novo组装软件，由三个独立的软件模块组成：Inchworm （虫）（C++） 、Chrysalis （蛹）（C++）、Butterfly （蝶）（Java）。三个软件依次来处理大规模的RNA-seq的reads数据。 组成部分 作用 工作过程 Inchworm （虫）（C++） 序列延伸 a. 将 reads切为 k-mers (k bp长度的短片段)b. 利用Overlap关系对k-mers进行延伸 (贪婪算法)c. 输出所有的序列 (“contigs”) Chrysalis （蛹）（C++） 构建de Brujin graph a. 聚类所有相似区域大于k-1bp的 contigsb. 构图 (区分不同的 “components”)c. 将reads比对回 components，进行验证 Butterfly （蝶）（Java） 解图，列举转录本 a. 拆分graph 为线性序列b. 使用reads以及 pairs关系消除错误序列 Trinity使用1. 下载与安装trinity最新版本是v2.4.0 下载官网在：https://github.com/trinityrnaseq/trinityrnaseq/wiki 12345nohup wget -c https://github.com/trinityrnaseq/trinityrnaseq/archive/Trinity-v2.4.0.tar.gz 1&gt;trinity.o 2&gt;trinity.e &amp; # 下载tar -zxvf Trinity-v2.4.0.tar.gz # 解压make # 编译 2. 使用命令：Trinity --seqType fq --left reads_1.fq --right reads_2.fq --CPU 6 --max_memory 20G 几个重要参数介绍： --seqType 支持输入数据格式为 fq 或者 fa双端测序：--left为read1 --right为read2 多个样品的reads由逗号隔开，不允许出现空格（依版本而定）单端测序：--single 加上文件 多个样品的reads由逗号隔开，不允许出现空格（依版本而定）--CPU 软件所用CPU数量--max_memory 内存控制（组装过程中，jellyfish这一步是最耗费资源的一步 所以这个内存主要由jellyfish控制）--SS_lib_type RF 链特异性文库需要加上这个参数，其中RF表示文库的构建方法，点这了解，最好看看--no_run_butterfly 不进行butterfly步骤，在Chrysalis这一步完成后中断--no_run_quantifygraph 不进行quantifygraph这一步--output trinity的输出文件夹，默认在trinity_out_dir/Trinity.fasta--no_version_check 不汇报版本信息 可选参数Misc：--SS_lib_type reads的方向。成对的reads: RF or FR; 不成对的reads: F or R。在数据具有链特异性的时候，设置此参数，则正义和反义转录子能得到区分。默认情况下，不设置此参数，reads被当作非链特异性处理。FR: 匹配时，read1在5’端上游, 和前导链一致, read2在3’下游, 和前导链反向互补. 或者read2在上游, read1在下游反向互补; RF: read1在5’端上游, 和前导链反向互补, read2在3’端下游, 和前导链一致;--output 输出结果文件夹。默认情况下生成trinity_out_dir文件夹并将输出结果保存到此文件夹中。--min_contig_length 报告出的最短的contig长度。默认为200--jaccard_clip 如果两个转录子之间有UTR区重叠，则这两个转录子很有可能在de novo组装的时候被拼接成一条序列，称为融合转录子(Fusion Transcript)。如果有fastq格式的paired reads，并尽可能减少此类组装错误，则选用此参数。值得说明的是：1. 适合于基因在基因组比较稠密，转录子经常在UTR区域重叠的物种，比如真菌基因组。而对于脊椎动物和植物，则不推荐使用此参数; 2. 要求fastq格式的paired reads文件(文件中reads名分别以/1和/2结尾，以利于软件识别)，同时还需要安装bowtie软件用于reads的比对; 3. 单独使用具有链特异性的RNA-seq数据的时候，能极大地减少UTR重叠区很小的融合转录子; 4. 此选项耗费运算，若没必要，则不用此参数。--prep 仅仅准备一些文件(利于I/O）并在kmer计算前停止程序运行--no_cleanup 保留所有的中间输入文件--full_cleanup 仅保留Trinity fasta文件，并重命名成${output_dir}.Trinity.fasta--cite 显示Trinity文献引证和一些参与的软件工具--version 报告Trinity版本并推出 Inchworm 和 K-mer 计算相关选项：--min_kmer_cov 使用Inchworm来计算K-mer数量时候，设置的Kmer的最小值。默认为1--inchworm_cpu Inchworm使用的CPU线程数，默认为6和–CPU设置的值中的小值。 Chrysalis相关选项：--max_reads_per_graph 在一个Bruijn图中锚定的最大的reads数目，默认为200000--no_run_chrysalis 运行Inchworm完毕，在运行chrysalis之前停止运行Trinity--no_run_quantifygraph 在平行化运算quantifygrahp前停止运行Trinity Butterfly相关选项：--bfly_opts Butterfly额外的参数--max_number_of_paths_per_node 从node A -&gt; B,最多允许多少条路径。默认为10--group_pairs_distance 最大插入片读长度，默认为500--path_reinforcement_distance 延长转录子路径时候，reads间最小的重叠碱基数。默认PE:75; SE：25--no_triplet_lock 不锁定triplet-supported nodes--bflyHeapSpaceMax 运行Butterfly时java最大的堆积空间，默认为20G--bflyHeapSpaceInit java初始的堆积空间，默认为1G--bflyGCThreads java进行无用信息的整理时使用的线程数，默认由java来决定--bflyCPU 运行Butterfly时使用的CPU线程数，默认为2--bflyCalculateCPU 计算Butterfly所运行的CPU线程数，由公式80% * max_memory / maxbflyHeapSpaceMax 得到--no_run_butterfly 在Chrysalis运行完毕后，停止运行Butterfly 结果 最终会得到一个Trinity.fasta的文件，在同文件夹下还会有其他的中间过程产生的文件，其中这个文件最为重要，是最终的组装结果 Trinity中自带脚本 for DifferentialExpression utils 三、下游分析（有待完善）1. GO功能注释2. KEGG通路分析3. 差异基因分析与筛选4. 功能和通路富集分析5. 结果可视化（火山图、箱线图、MAplot、pheatmap等）参考资料 https://github.com/trinityrnaseq/trinityrnaseq/wiki # 官方文档 https://www.meiwen.com.cn/subject/bnsokctx.html # 介绍博客 http://www.360doc.com/content/16/0910/15/35684706_589802384.shtml # 无参转录组分析 https://www.omicsclass.com/article/295 # 转录组学知识点 https://www.meiwen.com.cn/subject/tsutnqtx.html # 可视化分析（重点火山图） https://blog.csdn.net/niuhuihui_fei/article/details/72723781 # 介绍博客（Trinity参数）","link":"/2019/10/04/Bioinformatics/无参转录组分析/"},{"title":"Python基础","text":"这是一篇关于python基础知识复习的博客，除了基础之外，还会涉及进阶以及算法设计。 第一部分 Python基础语法1. 认识Python1.1. Python简介Python的创始人为Guido van Rossum Python 的设计目标： 一门简单直观的语言并与主要竞争者一样强大 开源，以便任何人都可以为它做贡献 代码像纯英语那样容易理解 适用于短期开发的日常任务 Python设计哲学 优雅、明确、简单 Python开发者的哲学是：用一种方法，最好只有一种方法来做一件事 Python是完全面向对象的语言，在Python中一切皆对象 可扩展性：如果需要一段关键代码运行的更快或者希望某些算法不公开，可以把这部分程序用C或者C++编写，然后在Python程序中使用它们。 1.2. 第一个Python程序执行Python程序的三种方式：解释器、交互式运行、IDE运行 Python是一个格式非常严格的程序设计语言。Python2.x默认不支持中文。 ASCII字符只包含256个字符，不支持中文 Python2.x的解释器名称是Python Python3.x的解释器名称是Python3 2. 注释 注释的作用 使用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性 2.1. 单行注释 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用1print(\"hello python\") # 输出'hello python' 为了保证代码的可读性，# 后面建议先添加一个空格，然后再编写相应的说明文字；为了保证代码的可读性，注释和代码之间 至少要有 两个空格。 2.2. 多行注释 要在 Python 程序中使用多行注释，可以用 一对 连续的 三个 引号(单引号和双引号都可以)123456\"\"\"这是一个多行注释在多行注释之间，可以写很多很多的内容……\"\"\"print(\"hello python\") 提示： 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上若干行注释 对于 不是一目了然的代码，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格） 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 2.3. 代码规范： Python 官方提供有一系列 PEP（Python Enhancement Proposals） 文档，其中第 8 篇文档专门针对 Python 的代码格式 给出了建议，也就是俗称的 PEP 8： 文档地址：https://www.python.org/dev/peps/pep-0008/ 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/ 3. 运算符3.1. 算数运算符 算数运算符是完成基本的算术运算使用的符号，用来处理四则运算，而“+”和“ * ”还可以用来处理字符串。 运算符 描述 实例 + 加 10 + 10 = 20 - 减 10 - 10 = 0 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 3.2. 比较（关系）运算符 运算符 描述 == 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True != 检查两个操作数的值是否 不相等，如果是，则条件成立，返回 True &gt; 检查左操作数的值是否 大于 右操作数的值，如果是，则条件成立，返回 True &lt; 检查左操作数的值是否 小于 右操作数的值，如果是，则条件成立，返回 True &gt;= 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True &lt;= 检查左操作数的值是否 小于或等于 右操作数的值，如果是，则条件成立，返回 True python2.x中判断 不等于 还可以使用&lt;&gt;运算符 python2.x中同样可以使用!=来判断不等于 3.3. 赋值运算符 在 Python 中，使用 = 可以给变量赋值。在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符，注意：赋值运算符中间不能使用空格。 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c *= a 等效于 c = c * a 3.4. 身份运算符身份运算符比较两个对象的内存位置。常用的有两个身份运算符，如下所述： 运算符 描述 示例 is 判断两个标识符是不是引用同一个对象 x is y，类似 id(x) == id(y) is not 判断两个标识符是不是引用不同对象 x is not y，类似 id(a) != id(b) 辨析 is 用于判断 两个变量引用的对象是否为同一个 == 用于判断 引用变量的值 是否相等 3.5. 成员运算符Python成员运算符测试给定值是否为序列中的成员。 有两个成员运算符，如下所述： 运算符 描述 in 如果在指定的序列中找到一个变量的值，则返回true，否则返回false。 not in 如果在指定序列中找不到变量的值，则返回true，否则返回false。 3.6. 逻辑运算符| 运算符 逻辑表达式 描述 and x and y 只有 x 和 y 的值都为 True，才会返回 True否则只要 x 或者 y 有一个值为 False，就返回 False or x or y 只要 x 或者 y 有一个值为 True，就返回 True只有 x 和 y 的值都为 False，才会返回 False not not x 如果 x 为 True，返回 False如果 x 为 False，返回 True 3.7. 运算符优先级 以下表格的算数优先级由高到最低顺序排列： 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 &lt;补&gt;程序执行原理 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中 Python 解释器 根据语法规则，从上向下 让 CPU 翻译 Python 程序中的代码 CPU 负责执行翻译完成的代码Python 的解释器有多大？ 执行以下终端命令可以查看 Python 解释器的大小12345678# 1. 确认解释器所在位置$ which python# 2. 查看 python 文件大小(只是一个软链接)$ ls -lh /usr/bin/python# 3. 查看具体文件大小$ ls -lh /usr/bin/python2.7 4. 变量4.1. 变量定义 在 Python 中，每个变量 在使用前都必须赋值，变量 赋值以后 该变量 才会被创建 可以用 其他变量的计算结果 来定义变量 变量名 只有在 第一次出现 才是 定义变量1变量名 = 值 使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用print函数使用解释器执行，如果要输出变量的内容，必须要要使用print函数 4.2. 变量的类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要），Python 可以根据 = 等号右侧的值，自动推导出变量中存储数据的类型 数据类型可以分为 数字型 和 非数字型 数字型 整型 (int)：Python3中的所有整数都表示为长整数。 因此，长整数没有单独的数字类型。 浮点型（float） 布尔型（bool） ：真 True 非 0 数 —— 非零即真，假 False 0。 复数型 (complex)：复数是由x + yj表示的有序对的实数浮点数组成，其中x和y是实数，j是虚数单位。 非数字型：有些运算符还支持这些数据类型，详见4.4.5.3 运算符。 字符串（str）：加号(+)是字符串连接运算符，星号(*)是重复运算符。 列表（list） 元组（tuple） 字典（dict） 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为： int（整数） long（长整数） 使用 type 函数可以查看一个变量的类型 1In [1]: type(name) &lt;补&gt;不同类型变量之间的计算 数字型变量 之间可以直接计算 在 Python 中，两个数字型变量是可以直接进行 算数运算的 如果变量是 bool 型，在计算时 True 对应的数字是 1 False 对应的数字是 0 字符串变量 之间使用 + 拼接字符串 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串 数字型变量 和 字符串 之间 不能进行其他计算&lt;补&gt;从键盘获取输入信息：input 在 Python 中可以使用 input 函数从键盘等待用户的输入 用户输入的 任何内容 Python 都认为是一个 字符串1字符串变量 = input(\"提示信息：\")","link":"/2019/09/29/Python/Python基础/"},{"title":"data_visualization","text":"开始学习数据可视化，在此记录，目前主要是先学Python中的matplotlib这个包，这个包和MATLAB中的作图很相似，具有很高的自定义性，等到这个学习的比较深入后再考虑了解拓展其他工具的作图。附上学习链接：https://matplotlib.org/gallery/index.html 直接到官网学习是最方便的，文档详细，demo生动。 目录 1. 基础画图 2. 画图进阶 第一部分：基础画图 1. 通用画图步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263① 引包：import matplotlib.pyplot as plt；② 创建画布：fig = plt.figure()；③ 添加分区：ax = fig.add_subplot(311) # 3个数字分别代表 行、列 及 本图所处位置；④ ax.axis([-5,5,0,1]) # 设置x轴最小、最大值，y轴最小、最大值；⑤ ax.scatter(xcord1,ycord1, s=30, c='red', marker='s') # 用于画散点图；⑥ ax.plot(x, y) # 用于画线图；⑦ plt.title(“this is a title”) # 图形添加标题；⑧ plt.xlabel('x')、plt.ylabel('y') # 分别对坐标轴添加标题⑨ plt.savefig(\"/path_way/img_name.jpg\") #调整好后，保存图片⑩ plt.show() # 显示图形；——————————————————————————————————————————————————————————# 第一步：导入工具包——matplotlib、numpy、matplotlib.pyplotimport matplotlibimport matplotlib.pyplot as pltimport numpy as np# 第二步：数据准备——将数据处理成对应图片所需的格式labels = ['G1', 'G2', 'G3', 'G4', 'G5']men_means = [20, 34, 30, 35, 27]women_means = [25, 32, 34, 20, 25]x = np.arange(len(labels)) # the label locations# 第三步：图片通用设置# Add some text for labels, title and custom x-axis tick labels, etc.ax.set_ylabel('Scores')ax.set_title('Scores by group and gender')ax.set_xticks(x)ax.set_xticklabels(labels)ax.legend()# 第四步：作图fig, ax = plt.subplots()rects1 = ax.bar(x - width/2, men_means, width, label='Men')rects2 = ax.bar(x + width/2, women_means, width, label='Women')width = 0.35 # the width of the barsdef autolabel(rects): \"\"\"Attach a text label above each bar in *rects*, displaying its height.\"\"\" for rect in rects: height = rect.get_height() ax.annotate('{}'.format(height), xy=(rect.get_x() + rect.get_width() / 2, height), xytext=(0, 3), # 3 points vertical offset textcoords=\"offset points\", ha='center', va='bottom')autolabel(rects1)autolabel(rects2)fig.tight_layout()# 第六步：确认完成后，以img_name.jpg文件名保存到目标路径下plt.savefig(\"D:/TECHENICLEARNING/Data_visualization/img_name.jpg\") # 导入.savefig()方法，添加路径，将图片保存到目标路径下### 这一步必须放在show之前，可以考虑先注释掉这一步，等到图片调整好后再取消注释保存图片！！！# 第五步：展示图片plt.show() # 调用.show()方法展示图片，以便修改 示例图片如下： 图中的绿色圈为后来添加上的，圈出的地方表示可以自定义 2. 散点图与折线图代码如下： 1234567891011121314151617181920212223242526272829303132333435363738# 导入工具包import matplotlibimport matplotlib.pyplot as pltimport numpy as np# 数据准备labels = ['G1', 'G2', 'G3', 'G4', 'G5']x = [20, 34, 30, 35, 27]y = [25, 32, 34, 20, 25]z = [[20,26],[34, 32],[30, 34],[35, 20],[27, 25]]# 初始化，全局标题fig = plt.figure()plt.title(\"plot and scatter\")# 第1幅散点图ax = fig.add_subplot(2, 2, 1)ax.scatter(x,y, s=30, c='red', marker='s')# 第2幅折线图ax2 = fig.add_subplot(2, 2, 2)ax2.plot(x)ax2.plot(y)# 第3幅折线图ax3 = fig.add_subplot(2, 2, 3)ax3.plot(z)# 第4幅折线与散点图ax4 = fig.add_subplot(2, 2, 4)ax4.scatter([1,2,3,4,5],y)ax4.plot([1,2,3,4,5],x)# 保存图片plt.savefig(\"D:/TECHENICLEARNING/Data_visualization/plot-scatter.jpg\")# 图片展示，会将上面所有的图都展示出来plt.show() 输出图片： 感悟：在这里是直接使用matplotlib自动画的折线图和散点图，做好的关键在与数据的准备，如果准备的数据好的话，可以直接调用.plot()输入一个变量画折线图，默认横轴为数组的序数；如果采用scatter画图的话，需要传入两个参数，第一个是x，一般是横轴，第二个是y，一般是因变量的值，需要注意这一点，参数数量要对。另外还有其他能够自定义图片的地方，后续会进一步介绍。 3. 柱状图代码如下： 1234567891011121314151617181920212223242526import matplotlibimport matplotlib.pyplot as pltimport numpy as npplt.figure(3)x_index = np.arange(5) #柱的索引x_data = ('A', 'B', 'C', 'D', 'E')y1_data = (20, 35, 30, 35, 27)y2_data = (25, 32, 34, 20, 25)bar_width = 0.35 #定义一个数字代表每个独立柱的宽度rects1 = plt.bar(x_index, y1_data, width=bar_width,alpha=0.4, color='b',label='legend1')#参数：左偏移、高度、柱宽、透明度、颜色、图例rects2 = plt.bar(x_index + bar_width, y2_data, width=bar_width,alpha=0.5,color='g',label='legend2')#参数：左偏移、高度、柱宽、透明度、颜色、图例#关于左偏移，不用关心每根柱的中心不中心，因为只要把刻度线设置在柱的中间就可以了plt.xticks(x_index + bar_width/2, x_data) #x轴刻度线plt.legend() #显示图例plt.title(\"bar\")plt.tight_layout() #自动控制图像外部边缘，此方法不能够很好的控制图像间的间隔plt.savefig(\"E:/Desktop/bar.png\") #格式采用.jpg或者.png都可以，注意的是，save图片需要再show之前，不然输出的图片为空白，可能原因是在show之后图片数据就清空了，所以保存后为空白plt.show() 图片输出： 感悟：在这里最好指定bar的宽度，否则默认的宽度画图非常奇怪，另外，如果要同时画多个柱形图在一个刻度上，需要指定好偏移度，避免bar相互重合，具体的参数可以看上面的设置。 4. 饼图代码如下： 12345678910111213141516171819202122import matplotlibimport matplotlib.pyplot as pltimport numpy as npx_data = ('A', 'B', 'C', 'D', 'E')y1_data = (20, 35, 30, 35, 27)y2_data = (25, 32, 34, 20, 25)colors = 'r','y','b','g','m'explode = (0, 0.1, 0, 0,0) # only \"explode\" the 2nd slice (i.e. 'E')fig = plt.figure()# plt.title(\"pie\")pie1 = fig.add_subplot(2,1,1)pie1.pie(y1_data, colors=colors,shadow=True, startangle=90, explode=explode, labels=x_data, autopct='%1.1f%%')pie1.axis('equal') # set the pie to be a circle.pie2 = fig.add_subplot(2,1,2)pie2.pie(y2_data, colors=colors,shadow=True, startangle=90, explode=explode, autopct='%1.1f%%', labels=x_data)pie2.axis('equal') # set the pie to be a circle.fig.savefig(\"pie.png\")plt.show() 图片输出： 感悟：这个饼状图是真的丑，颜色的透明度没有办法设置，而且默认不是圆形的，看起来实在难看，可以考虑有没有替代的方案。&gt;有.axis(‘equal’)这个参数可以设置为圆形。 补充 线条标记种类： 图片中颜色 如果这些颜色不够用的话，还可以这么做：（1）通过十六进制字符串 color=’#123456’指定或者使用合法的HTML颜色名字（’red’,’chartreuse’等）。(2)传入一个归一化到[0,1]的RGB元组，如color=(0.3,0.3,0.4) 第二部分：画图进阶1. 数学函数图像命令如下： 123456789101112131415161718192021222324252627282930import matplotlibimport matplotlib.pyplot as pltimport numpy as np# Data for plottingt = np.arange(-2.0, 2.0, 0.01)x = np.arange(-2.0, 2.0, 0.01)x2 = np.arange(0.1, 2.0, 0.1)s = np.sin(2 * np.pi * t)S = np.cos(2 * np.pi * t)y = 2*x*xz = np.log10(x2) + 1a = 4*x*x*x + x*x + xfig, ax = plt.subplots()ax.axis([-2, 2, -2, 4])ax.plot(t, s, label='y = sinx')ax.plot(t, S, label='y = cosx')ax.plot(x, y, label='y = x^2')ax.plot(x2, z, label='y = log10(x) + 1')ax.plot(x, a, label='y = 4x^3 + x^2 + x')ax.legend() # 显示图例，不调用默认不显示ax.set(xlabel='x axis', ylabel='y axis', title='About as simple as it gets, folks') # 通用设置ax.grid()fig.savefig(\"test.png\")plt.show() 输出图片： Be careful about that, in python, if you want to draw a image with mathmatics functions, you should import the pakage named numpy. 2. 虚线代码如下： 12345678910111213141516171819import matplotlibimport matplotlib.pyplot as pltimport numpy as npx = np.linspace(0, 10, 500)y = np.sin(x)fig, ax = plt.subplots()# Using set_dashes() to modify dashing of an existing lineline1, = ax.plot(x, y, label='Usinghahahha')line1.set_dashes([2, 2, 10, 2]) # 2pt line, 2pt break, 10pt line, 2pt break# Using plot(..., dashes=...) to set the dashing when creating a lineline2, = ax.plot(x, y - 0.2, dashes=[6, 2], label='Using the dashes parameter')ax.legend()plt.show() 图片输出： 3. 引入ggplot stylecode: 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npimport matplotlib.pyplot as pltplt.style.use('ggplot') # use the line of code to import the ggplot style# Fixing random state for reproducibilitynp.random.seed(19680801)fig, axes = plt.subplots(ncols=2, nrows=2)ax1, ax2, ax3, ax4 = axes.ravel()# scatter plot (Note: `plt.scatter` doesn't use default colors)x, y = np.random.normal(size=(2, 200))ax1.plot(x, y, 'o')# sinusoidal lines with colors from default color cycleL = 2*np.pix = np.linspace(0, L)ncolors = len(plt.rcParams['axes.prop_cycle'])shift = np.linspace(0, L, ncolors, endpoint=False)for s in shift: ax2.plot(x, np.sin(x + s), '-')ax2.margins(0)# bar graphsx = np.arange(5)y1, y2 = np.random.randint(1, 25, size=(2, 5))width = 0.25ax3.bar(x, y1, width)ax3.bar(x + width, y2, width, color=list(plt.rcParams['axes.prop_cycle'])[2]['color'])ax3.set_xticks(x + width)ax3.set_xticklabels(['a', 'b', 'c', 'd', 'e'])# circles with colors from default color cyclefor i, color in enumerate(plt.rcParams['axes.prop_cycle']): xy = np.random.normal(size=2) ax4.add_patch(plt.Circle(xy, radius=0.3, color=color['color']))ax4.axis('equal')ax4.margins(0) # control the elements to be on the right place.plt.show() 图片输出 图片一下子的就精美多了，当然主要是替换了图片的通用设置，图片中元素的颜色还是需要自己搭配的。","link":"/2019/10/27/Python/data-visualization/"},{"title":"seaborn_visualization","text":"New package for data visualization. This package is base on the matplotlib, numpy, scipy , and pandas. The shining point is that this package is easier for people to create a beautiful picture for your dataset, this is essential for the data science. So let’s get it. This is the official URL: http://seaborn.pydata.org/ You can turn to there for help. 目录 可视化统计关系 绘制分类数据 数据分布 双变量分布 Step0：什么是seaborn Seaborn是基于matplotlib的图形可视化python包。它提供了一种高度交互式界面，便于用户能够做出各种有吸引力的统计图表。 Seaborn是在matplotlib的基础上进行了更高级的API封装，从而使得作图更加容易，在大多数情况下使用seaborn能做出很具有吸引力的图，而使用matplotlib就能制作具有更多特色的图。应该把Seaborn视为matplotlib的补充，而不是替代物。同时它能高度兼容numpy与pandas数据结构以及scipy与statsmodels等统计模式。 seaborn 有五种风格，分别为”darkgrid”, “whitegrid”, “dark”, “white”, “ticks” Step1: 数据来源 https://datahack.analyticsvidhya.com/contest/wns-analytics-hackathon-2018-1/https://datahack.analyticsvidhya.com/contest/enigma-codefest-machine-learning-1/ 这是从相关的数据科学竞赛网站上下载的数据，需要先注册并且参加竞赛才能下载数据。 Step2: 准备工作1234567891011121314151617181920212223242526272829### 导入package和依赖包import numpy as npimport matplotlib.pyplot as pltimport seaborn as snsimport pandas as pdfrom scipy import stats# 导入数据，探索数据，了解数据data1 = pd.read_csv(r'./data/hr.csv')# data1.head()# data1.describe()# data1.columns\"\"\"da.columnsOut[6]: Index(['employee_id', 'department', 'region', 'education', 'gender', 'recruitment_channel', 'no_of_trainings', 'age', 'previous_year_rating', 'length_of_service', 'KPIs_met &gt;80%', 'awards_won?', 'avg_training_score', 'is_promoted'], dtype='object')\"\"\"# seaborn使用测试test = sns.relplot(x=\"Views\", y=\"Upvotes\", data = data2) # sns.relplot()作图test.savefig('test.png') # 保存图片，通用操作plt.show() # 展示图片 1. 可视化统计关系 包括以下内容： Scatter plot (散点图) SNS.relplot Hue plot (Hue图) 数据： 散点图123456# 开始使用seabornscatters = sns.relplot(x='Views', y='Upvotes', data=data2)plt.title('scatters with seaborn')scatters.savefig('scatters.png')plt.show() 图片输出： relplot的参数： relplot(x=None, y=None, hue=None, size=None, style=None, data=None, row=None, col=None, col_wrap=None, row_order=None, col_order=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None, size_norm=None, markers=None, dashes=None, style_order=None, legend=’brief’, kind=’scatter’, height=5, aspect=1, facet_kws=None, **kwargs) SNS.relplot是来自SNS类的relplot函数，SNS类是我们在上面与其他依赖项一起导入的一个seaborn类。这里，参数是x、y，数据有在X,Y轴上表示的变量和我们要分别画出来的数据点，通过图片，我们发现了views和upvotes之间的关系。 展示标签12scatters = sns.relplot(x='Views', y='Upvotes', hue='Tag', data=data2)# 增加hue（色调），可以展示标签 图片输出： Hue图 我们可以在色调(Hue)的帮助下在我们的图片中添加另一个维度，即在二维的基础上通过颜色来添加其他信息，通过为点赋予颜色来实现，每种颜色都有一些附加的意义。 1scatters = sns.relplot(x='Views', y='Upvotes', hue='Answers', data=data2) 图片输出： size标签1scatters = sns.relplot(x='Views', y='Upvotes', hue='Answers', data=data2) 图片输出： 2. 绘制分类数据 包括以下内容： 抖动图 Hue图 箱线图 小提琴图 Pointplot 数据： 抖动图1shake = sns.catplot(x=\"education\", y=\"avg_training_score\", jitter = True, data=df2) 图片输出： 改动jitter参数为False，可见下图： hue引入另一个维度1shake = sns.catplot(x=\"education\", y=\"avg_training_score\", hue='gender', data=df2) 引入了性别参数，可以看出数据中的性别差异 图片输出： 可以引入kind中的swarm参数，展示效果如下： 箱线图1shake = sns.catplot(x=\"education\", y=\"avg_training_score\", hue='gender', kind='box', data=df2) 图片输出： 箱线图（Boxplot）也称箱须图（Box-whisker Plot），是利用数据中的五个统计量：最小值、第一四分位数、中位数、第三四分位数与最大值来描述数据的一种方法，它也可以粗略地看出数据是否具有有对称性，分布的分散程度等信息，特别可以用于对几个样本的比较。 小提琴图1shake = sns.catplot(x=\"education\", y=\"avg_training_score\", hue='gender', kind='violin', data=df2) 图片输出： 小提琴图结合了箱线图和核密度估计程序，以提供更丰富的值分布描述。四分位数值显示在小提琴内部。当色调语义参数是二值时，我们还可以拆分小提琴，这也可能有助于节省绘图空间。 增加划分功能 1shake = sns.catplot(x=\"education\", y=\"avg_training_score\", hue='gender', kind='violin',split = True, data=data1) 图片输出： bar 结合 box1shake = sns.catplot(x=\"education\", y=\"avg_training_score\", hue='gender', kind='bar', data=data1) 图片输出： point图1shake = sns.catplot(x=\"education\", y=\"avg_training_score\", hue='gender', kind='point', data=data1) 图片输出： 3. 数据分布 数据分布图12tr = sns.distplot(data1.length_of_service)# tr = sns.distplot(data1.age) 通过displot()方法可以了解数据集的分布情况，也是一个不错的工具。 图片输出： 数据直方图1tr = sns.distplot(data1.length_of_service, kde=False, rug = True) 图片输出： 下面展示的转录组数据的分布 由此可以看出绝大部分的转录本都分布在1000bp左右，超过10000bp的转录本只有几个。 4. 双变量分布包括以下内容： Hex图 KDE 图 Boxen 图 Ridge 图 (Joy图) joinplot()默认为scatter1sns.jointplot(x=\"avg_training_score\", y=\"age\", data=data1, color='r', alpha = 0.2, kind='hex') 图片输出： 如果有时候要展示两个变量之间的关系，同时又想展示单个变量的分布时，可以用这种展示方法 直方图hex1sns.jointplot(x=\"age\", kind='hex', y=\"avg_training_score\", data=data1, color='b') 图片输出： KDE1sns.jointplot(x=\"age\", kind='kde', y=\"avg_training_score\", data=data1, color='b') 图片输出： heatmap()123456corrmat = data1.corr()f, ax = plt.subplots(figsize=(9, 6)) # figsize参数可以指定图片大小比例sns.heatmap(corrmat, vmax=.8, square=True)plt.savefig('./img/heatmap.png', dpi=1080) # dpi参数能够指定图片质量（像素） dpi参数能够指定图片质量（像素） figsize参数可以指定图片大小比例图片输出： heatmap中，每一个变量都是一种颜色，方便区分。 boxen图 catplot()1sns.catplot(x=\"age\", y=\"avg_training_score\", data=data1, kind=\"boxen\",height=4, aspect=2.7, hue = \"is_promoted\") 图片输出： 结语这一篇博客介绍了很多seaborn画图的图标，接下来需要做的就是在实际工作生活中应用这些画图的方式，并且可以尝试着更多的其他类型的图片，充分展示数据。继续学习！！！","link":"/2019/11/02/Python/seaborn-visualization/"},{"title":"数据结构与算法","text":"写在前面 这是篇为了记录计算机基础知识学习笔记的博客，希望自己能够充分利用博客这个工具，提高自己的学习效率和改善学习效果。另外，这也是在接下来的计算机二级考试的备考内容之一。这会是一篇持续更新的博客，希望能够写得完善一些。 1. 什么是算法？ 算法是指对解决方案的准确而完整的描述，简单来说，就是解决问题的步骤。 基本特征 具体描述 可行性 步骤可以实现，执行能够达到预期目的 确定性 步骤明确，每一步意义清晰 有穷性 有限步骤，有限时间内能完成 算法的复杂度 时间复杂度：执行算法所需要的计算工作量 空间复杂度：执行算法需要的内存空间 2. 数据结构的基本概念（1）什么是数据结构？ 数据结构值得是相互有关联的数据元素的集合。 逻辑结构 存储结构 （2）数据结构的表示1234B = (D, R)B表示数据结构D是数据元素的集合R是数据各元素之间的关系 基本概念 含义 根节点 数据结构中没有前件的节点 叶子节点 没有后件的节点 内部节点 除了根节点和叶子节点外的节点 ### （3）线性结构与非线性结构 基本概念 含义 —- —- 线性结构 非空，每一个节点最多有一个前件和一个后件 非线性结构 非空，每一个节点可以有多于一个前件或后件的数据结构 3. 线性表及其顺序储存结构（1）线性表 线性表即线性数据结构，表示如下 1(a1, a2, a3, ...,ai,...,an) 通常，线性表可以采用顺序存储和链接存储两种存储结构|基本概念|含义||—-|—-||顺序存储|存储地址是连续的、相邻的||链接存储|存储地址可以不连续，不过在逻辑上是连续的，由头指针和尾指针进行定位| 采用顺序存储是表示线性表最为简单的方法，这种顺序表示的线性表也称顺序表 4. 栈（Stack）与队列（Queue）(1)栈及其基本运算 栈是一种特殊的线性表，先进后出、后进先出原则，操作有三：入栈、退栈、读栈 （2）队列及其基本运算 队列也是一种特殊的线性表，先进先出、后进后出，运算多为指针头移动 循环队列：即最后一个元素的指针将指回第一个元素前一个空元素的位置，导致前后相连。 5. 线性链表（1）线性链表的基本概念 线性链表是指在线性表的链式存储结构，简称链表。占用空间除了数据域，还有指针域，故而会比较多空间。一般链表为单向链表，但是如果在每一项之中添加一个指向前一个元素的指针，那就可以变成双向链表。 类型 优点 缺点 顺序表 （1）可以随机存取表中任意节点（2）地址顺序即逻辑顺序，无需额外空间 （1）插入和删除的运算效率低下（2）储存空间不便于扩展（3）不便于储存空间动态分配 链表 （1）插入、删除只需移动指针，无需移动储存位置（2）空间易扩展，方便动态分配空间 需要额外的空间储存逻辑关系，存储密度比顺序表低 （2）循环链表 在单链表的第一个节点前增加一个表头节点，队头指针指向表头节点，最后一个节点的指针域的值由NULL改为指向表头节点，这样就形成了一个循环链表。 在循环链表中，只要知道了一个节点的位置，就可以从它出发访问到所有的节点，并且在链表为空时，链表中仍然还有表头节点这个节点，因此能够当成非空链表运算，因此统一了空链表与非空链表的运算。 6. 树与二叉树（1）树的基本概念 树（Tree）是一种简单的非线性结构。例如家族族谱关系等。 基本概念 含义 例子 父节点 在树结构中，每一个节点只有一个前件，即它的父节点，所有节点最终的父节点为根节点。 如从一棵树的所有枝丫都发源于树干，树干有个根。 子节点 每个节点可以有多个后件，这些后件即为子节点，没有后件的节点称为叶子节点 正如树的叶子是树的结构的末端，其后没有其他节点了 度 一个节点拥有的后件的个数称为该节点的度，所有节点中最大的度即为该树的度（注意，后件的后件不是该节点的后件）。 例如树的各个枝丫上有数量不同的枝丫或者树叶，这个数量就是目前枝丫的度 深度 定义根所在的层次为1，其他节点所在层次等于它的父节点所在层次+1，树最大的层次即为树的深度 如果从根算起，最多共经过4次转折到达了叶子的节点，那么这棵树的深度即为4+1=5 子树 在树中，以某一个节点为根构建的新的树，称为该树的子树 相当于树上的大树枝，如果把大树枝看成是起点的话，那这个构建的新的树就是原来树的子树 （2）二叉树 二叉树与树不同，但是与树的结构很相似。（我个人觉得，二叉树就是一种特殊的树结构） 特点如下 可以为空，空的二叉树没有节点，非空的二叉树有且只有一个根节点。 每个节点最多有两棵子树，即不存在度大于2的节点。 子树有左右之分，次序不能颠倒。 性质如下 在二叉树的第k层上最多有2^(k-1)个几点，k大于等于1。 深度为m的二叉树，最多有2^m-1个节点（比如深度为4的树最多有2^4-1=16-1=15个节点）。 任何一棵树，其中度为0的叶子节点总是比度为2的节点的数量多1个（可以自己分类讨论进行验证）。 具有n个节点的二叉树，其深度至少为n对2取对数运算的整数部分（记为d），则深度至少为d+1,即相当于是2^d-1=n。 具有n个节点的完全二叉树的深度为d+1（d含义同上）。 满二叉树是指除了最后一层外，其他层的节点都是度为2的节点。完全二叉树是指除了最后一层外，每一层的节点数均达到最大值，在最后一层上只缺少右边的若干节点的二叉树。 （3）二叉树的存储结构 在计算机中，二叉树通常采用链式存储结构。其存储的节点由数据域与指针域两部分组成，由于每一个节点可以有两个后件，所以每个节点需要有2个指针，分别为左指针域和右指针域。二叉树的链式存储结构也叫二叉链表。 遍历方法 含义 前序遍历 首先访问根节点，然后按照先左后右的原则一直访问到叶子节点，例子如下图前序遍历，遍历顺序为A B D H E I C F G。 中序遍历 首先遍历左子树，然后访问根节点，最后遍历右子树。例子如下图，遍历顺序为H D B E I A C G F。 后序遍历 先左子树，后右子树，最后根节点。如下图，遍历顺序为H D I E B G F C A。 7. 查找技术 概念 含义 分析 顺序查找 从线性表的第一个元素开始，逐个比较最终找出目标元素，查找停止 （1）最好的时候，第一个即为查找元素，比较次数为1。（2）最坏情况，最后一个才是目标元素，比较次数为n。综上，平均为(n+1)/2 二分法查找 在有序的线性表中，将查找元素与中间元素进行比较，以指数级速度缩小查找范围，最终锁定目标元素。 最好情况为比较1次，最差情况为比较log..n次（‘..’表示数字‘2’）。 8. 排序技术 概念 含义 分析 冒泡排序法 通过两两相邻的数据之间比较，不断调整大小顺序，不断的重复，直到所有的数据都有序为止 最坏情况，比较次数为(n-1)n/2 快速排序法 在待排序元素中选取一个数K（一般为第一个数），以K为标准，大于K的排在K后面，小于K的排在K前面，得到两个子表，对这两个子表进行同样的操作，直到所有的数均有序后停止。 最坏情况，比较次数为(n-1)n/2 简单插入排序法 把待排序的n个元素看成是有序表和无序表，最开始有序表只有1个元素，无序表有n-1个元素，接下来在无序表中选取元素插入有序表中的正确位置，重复操作直到所有元素都插入到了正确的位置即停止。 最多比较(n-1)n/2次 希尔排序 将n个元素分为a1个组（a &lt; n），在每一组之间进行简单排序，再将序列分为a2个组（a2 &lt; a1），重复操作，直到最后an=1，即只有一个分组时排序完成。 最多次数为n^r，其中（1&lt; r &lt; 2）。 简单选择排序法 先选出最小元素与第一个元素交换位置，剩下元素再找最小元素与第二个元素交换位置，直到所有排序完毕。 最多比较(n-1)n/2次 堆排序法 堆是一个比较特别的完全二叉树的结构，在这种特殊情况下进行特殊排序，称为堆排序法。 最多nlog..n次，其中‘..’表示数字‘2’。 堆是用数组表示的二叉树，在堆里面，只有数组元素的排列顺序，没有额外的逻辑数据，在某些条件下，堆的优势很明显。 结语 写到这，关于数据结构与算法的基础入门知识就是这些了，还有一些其他内容还要进一步学习。","link":"/2019/09/03/计算机基础/数据结构与算法/"},{"title":"无参转录组实战case_1","text":"这是来自实验室的数据，开始做无参转录组第一次尝试，在此记录过程。这个记录会详尽的记录在时间过程中遇到的问题以及一些学习的细节，但是为了避免文章过于冗长，采用了Markdown中插入HTML标签的方式进行折叠，需要查看即点击查看即可。 前情提要：分析流程 目录 序列拼接 去冗余 cd-hit-est 拼接结果参数统计 TrinityStats.pl 表达水平评估 align_and_estimate_abundance.pl 生成数量矩阵 abundance_estimates_to_matrix.pl 下游分析 差异表达分析 run_DE_analysis.pl 提取最长链 提取蛋白编码区 transcripts_to_best_scoring_ORFs.pl 功能注释 生成报告 数据可视化 1. 拼接序列 Trinity Trinity –seqType fq –max_memory 50G –output trinity_out_dir3 –left LJG-134_TTAGGC_L008_R1_001.fastq_trimmed,LJG-144_TGACCA_L008_R1_001.fastq_trimmed LJG-155_ACAGTG_L008_R1_001.fastq_trimmed,LJG-531_GCCAAT_L008_R1_001.fastq_trimmed,LJG-543new_CAGATC_L008_R1_001.fastq_trimmed,LJG-556_ACTTGA_L008_R1_001.fastq_trimmed,LJG-B1_CGATGT_L008_R1_001.fastq_trimmed,LJG-Xnew_GATCAG_L008_R1_001.fastq_trimmed,LJG-Y1_ATCACG_L008_R1_001.fastq_trimmed –right LJG-134_TTAGGC_L008_R2_001.fastq_trimmed,LJG-144_TGACCA_L008_R2_001.fastq_trimmed,LJG-155_ACAGTG_L008_R2_001.fastq_trimmed,LJG-531_GCCAAT_L008_R2_001.fastq_trimmed,LJG-543new_CAGATC_L008_R2_001.fastq_trimmed,LJG-556_ACTTGA_L008_R2_001.fastq_trimmed,LJG-B1_CGATGT_L008_R2_001.fastq_trimmed,LJG-Xnew_GATCAG_L008_R2_001.fastq_trimmed,LJG-Y1_ATCACG_L008_R2_001.fastq_trimmed –CPU 25 –min_kmer_cov 2+ Trinity –seqType fq –max_memory 50G –output trinity_out_dir –left LJG-134_TTAGGC_L008_R1_001.fastq_trimmed,LJG-144_TGACCA_L008_R1_001.fastq_trimmed,LJG-155_ACAGTG_L008_R1_001.fastq_trimmed,LJG-531_GCCAAT_L008_R1_001.fastq_trimmed,LJG-543new_CAGATC_L008_R1_001.fastq_trimmed,LJG-556_ACTTGA_L008_R1_001.fastq_trimmed,LJG-B1_CGATGT_L008_R1_001.fastq_trimmed,LJG-Xnew_GATCAG_L008_R1_001.fastq_trimmed,LJG-Y1_ATCACG_L008_R1_001.fastq_trimmed –right LJG-134_TTAGGC_L008_R2_001.fastq_trimmed,LJG-144_TGACCA_L008_R2_001.fastq_trimmed,LJG-155_ACAGTG_L008_R2_001.fastq_trimmed,LJG-531_GCCAAT_L008_R2_001.fastq_trimmed,LJG-543new_CAGATC_L008_R2_001.fastq_trimmed,LJG-556_ACTTGA_L008_R2_001.fastq_trimmed,LJG-B1_CGATGT_L008_R2_001.fastq_trimmed,LJG-Xnew_GATCAG_L008_R2_001.fastq_trimmed,LJG-Y1_ATCACG_L008_R2_001.fastq_trimmed –CPU 30 –min_kmer_cov 2 输出文件：trinity_out_dir/ 反馈如下 展开查看 （1）实测失败，报错如下 Error, not recognizing read name formatting: [GWZHISEQ02:77:C3VBWACXX:8:1203:2388:]If your data come from SRA, be sure to dump the fastq file like so: SRA_TOOLKIT/fastq-dump –defline-seq ‘@$sn[_$rn]/$ri’ –split-files file.sra Thread 2 terminated abnormally: Error, cmd: seqtk-trinity seq -A /home/gaodong/Zhangjlin/LJG-144_TGACCA_L008_R2_001.fastq &gt;&gt; right.fa died with ret 512 at /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/insilico_read_normalization.pl line 762.Error, conversion thread failed at /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/insilico_read_normalization.pl line 333.Error, cmd: /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/insilico_read_normalization.pl 已解决 通过 df -h查看到系统中内存不足，切换到新的文件夹后可以运行，同时将.fastq文件替换成了.fastq_trimed 新反馈如下 补充：Linux技巧 考虑到在运行过程中可能会突然断网，在运行程序是切换到后台运行，有两种方法，第一种是nohub，第二种是screen，具体的操作方法可以使用-h参数查看 （2）报错如下 Trinity run failed. Must investigate error above.There is insufficient memory for the Java Runtime Environment to continue.Cannot create GC thread. Out of system resources.An error report file with more information is saved as:/B313/gaodong/Zhangjlin/trinity_out_dir/read_partitions/Fb_0/CBin_23/c2318.trinity.reads.fa.out/hs_err_pid142493.logwarning, cmd: /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/support_scripts/../../Trinity –single “/B313/gaodong/Zhangjlin/trinity_out_dir/read_partitions/Fb_0/CBin_163/c16382.trinity.reads.fa” –output “/B313/gaodong/Zhangjlin/trinity_out_dir/read_partitions/Fb_0/CBin_163/c16382.trinity.reads.fa.out” –CPU 1 –max_memory 1G –run_as_paired –seqType fa –trinity_complete –full_cleanup –min_kmer_cov 2 failed with ret: 65280, going to retry. （3）报错如下 Thursday, October 24, 2019: 00:40:07 CMD: /B313/public_software/trinityrnaseq-Trinity-v2.8.4/trinity-plugins/BIN/ParaFly -c recursive_trinity.cmds -CPU 30 -v -shuffleNumber of Commands: 38759succeeded(1) 0.00258005% completed. Error occurred during initialization of VM (4)报错如下 Error encountered:: &lt;!—-CMD: /B313/public_software/trinityrnaseq-Trinity-v2.8.4/trinity-plugins/BIN/ParaFly -c /B313/gaodong/Zhangjlin/trinity_out_dir/read_partitions/Fb_0/CBin_163/c16382.trinity.reads.fa.out/chrysalis/butterfly_commands -shuffle -CPU 1 -failed_cmds failed_butterfly_commands.138858.txt 2&gt;tmp.138858.1571848809.stderr 拼接结果 2. 去冗余 cd-hit-est命令如下 cd-hit-est -i input.fasta -o output.fasta -c 0.90 -n 8 -T 12 输出文件：output.fasta 反馈如下 展开查看 参数注释|参数|参数注释||:—-:|:—-:|| -i|input filename in fasta format, required, can be in .gz format|| -o|output filename, required||-c|sequence identity threshold, default 0.9this is the default cd-hit’s “global sequence identity” calculated as:number of identical amino acids or bases in alignmentdivided by the full length of the shorter sequence||-G|use global sequence identity, default 1if set to 0, then use local sequence identity, calculated as :number of identical amino acids or bases in alignmentdivided by the length of the alignmentNOTE!!! don’t use -G 0 unless you use alignment coverage controlssee options -aL, -AL, -aS, -AS||-b|band_width of alignment, default 20||-M|memory limit (in MB) for the program, default 800; 0 for unlimitted;||-T|number of threads, default 1; with 0, all CPUs will be used||-n|word_length, default 5, see user’s guide for choosing it||-l|length of throw_away_sequences, default 10||-t|tolerance for redundance, default 2||-d|length of description in .clstr file, default 20||if|set to 0, it takes the fasta defline and stops at first space||-s|length difference cutoff, default 0.0|if set to 0.9, the shorter sequences need to beat least 90% length of the representative of the cluster||-S|length difference cutoff in amino acid, default 999999if set to 60, the length difference between the shorter sequencesand the representative of the cluster can not be bigger than 60||-aL|alignment coverage for the longer sequence, default 0.0,if set to 0.9, the alignment must covers 90% of the sequence||-AL|alignment coverage control for the longer sequence, default 99999999if set to 60, and the length of the sequence is 400,then the alignment must be &gt;= 340 (400-60) residues||-aS|alignment coverage for the shorter sequence, default 0.0, if set to 0.9, the alignment must covers 90% of the sequence||-AS|alignment coverage control for the shorter sequence, default 99999999, if set to 60, and the length of the sequence is 400,then the alignment must be &gt;= 340 (400-60) residues||-A|minimal alignment coverage control for the both sequences, default 0, alignment must cover &gt;= this value for both sequences||-uL|maximum unmatched percentage for the longer sequence, default 1.0, if set to 0.1, the unmatched region (excluding leading and tailing gaps), must not be more than 10% of the sequence||-uS|maximum unmatched percentage for the shorter sequence, default 1.0, if set to 0.1, the unmatched region (excluding leading and tailing gaps), must not be more than 10% of the sequence||-U|maximum unmatched length, default 99999999, if set to 10, the unmatched region (excluding leading and tailing gaps), must not be more than 10 bases||-B|1 or 0, default 0, by default, sequences are stored in RAM, if set to 1, sequence are stored on hard drive !! No longer supported !!||-p|1 or 0, default 0, if set to 1, print alignment overlap in .clstr file||-g|1 or 0, default 0, by cd-hit’s default algorithm, a sequence is clustered to the first cluster that meet the threshold (fast cluster). If set to 1, the program will cluster it into the most similar cluster that meet the threshold(accurate but slow mode), but either 1 or 0 won’t change the representatives of final clusters||-sc|sort clusters by size (number of sequences), default 0, output clusters by decreasing length, if set to 1, output clusters by decreasing size||-sf|sort fasta/fastq by cluster size (number of sequences), default 0, no sorting, if set to 1, output sequences by decreasing cluster size, this can be very slow if the input is in .gz format||-bak|write backup cluster file (1 or 0, default 0)||-h| print this help| 再做一次结果统计 /B313/public_software/trinityrnaseq-Trinity-v2.8.4/utilTrinityStats.pl /B313/gaodong/Zhangjlin/trinity_out_dir/Trinity90.fasta 结果如下： 3. 拼接结果参数统计 TrinityStats.pl 统计结果包括统计在文件里面，各种长度的contig的数量，然后进行筛选。在筛选Contig的时候可以采用225作为一个阈值，这相当于是75个氨基酸的长度，这是针对于整个基因组寻找一些经典基因而采用的经验阈值，当然，也可以根据具体的分析目的进行设计。要熟悉在Linux中例如像Excel中常用的一些数据处理的指令。 命令如下 /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/TrinityStats.pl Trinity.fasta 结果反馈如下： 展开查看 数据处理： perl /home/gaodong/length_calculate.pl Trinity90.fasta &gt; Trinity90_counts #读取Trinity90.fasta文件中的length参数进行统计，并输出到Trinity90_counts中 awk ‘$4&gt;225’ Trinity90_counts &gt; Trinity90_counts_225 # 使用awk处理文件，筛选其中长度大于225的行 awk ‘{print $2}’ Trinity90_counts_225 &gt; Trinity90_counts_lens # 使用awk处理文件，筛选第二行 awk -F ‘[=]’ ‘{print $NF}’ Trinity90_counts_lens &gt; Trinity90_counts_list #使用awk处理文件，处理第二行中的字符串，输出所有数据到list里 sort -n -r number.txt -o number.txt #按照数值（-n）进行倒序（-r）排序，输出文件（-o） 参数如下： 展开查看 -f：忽略大小写；-b：忽略每行前面的空白部分；-n：以数值型进行排序，默认使用字符串排序；-r：反向排序；-u：删除重复行。就是 uniq 命令；-t：指定分隔符，默认分隔符是制表符；-k [n,m]：按照指定的字段范围排序。从第 n 个字段开始，到第 m 个字（默认到行尾）； 补充：提取最长链 get_longest_isoform_seq_per_trinity_gene.pl perl /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/misc/get_longest_isoform_seq_per_trinity_gene.pl Trinity90.fasta &gt; longest_transcript.fasta 输出文件：longest_transcript.fasta 坑：这里输入的文件第一行是统计数据，第二行是序列，两列一组，然后由长到短排序，如果要提取某一行序列数据，则设置提取偶数行即可。 4. 表达水平评估 align_and_estimate_abundance.pl命令如下：注意：每一对reads要单独mapping nohup /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/align_and_estimate_abundance.pl –transcripts ./trinity_out_dir/Trinity.fasta –seqType fq –est_method RSEM –aln_method bowtie –trinity_mode –prep_reference –output_dir rsem_outdir –leftLJG-134_TTAGGC_L008_R1_001.fastq_trimmed,LJG-144_TGACCA_L008_R1_001.fastq_trimmed,LJG-155_ACAGTG_L008_R1_001.fastq_trimmed,LJG-531_GCCAAT_L008_R1_001.fastq_trimmed,LJG-543new_CAGATC_L008_R1_001.fastq_trimmed,LJG-556_ACTTGA_L008_R1_001.fastq_trimmed,LJG-B1_CGATGT_L008_R1_001.fastq_trimmed,LJG-Xnew_GATCAG_L008_R1_001.fastq_trimmed,LJG-Y1_ATCACG_L008_R1_001.fastq_trimmed –rightLJG-134_TTAGGC_L008_R2_001.fastq_trimmed,LJG-144_TGACCA_L008_R2_001.fastq_trimmed,LJG-155_ACAGTG_L008_R2_001.fastq_trimmed,LJG-531_GCCAAT_L008_R2_001.fastq_trimmed,LJG-543new_CAGATC_L008_R2_001.fastq_trimmed,LJG-556_ACTTGA_L008_R2_001.fastq_trimmed,LJG-B1_CGATGT_L008_R2_001.fastq_trimmed,LJG-Xnew_GATCAG_L008_R2_001.fastq_trimmed,LJG-Y1_ATCACG_L008_R2_001.fastq_trimmed &gt;mynohup.out 2&gt;&amp;1 &amp; 输出文件如下 5. 生成数量矩阵 abundance_estimates_to_matrix.pl命令如下： /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/abundance_estimates_to_matrix.pl –est_method RSEM –gene_trans_map none RSEM.isoforms.results 结果如下(自动输出文件到当前目录) 相关参数 展开查看 Usage: ./abundance_estimates_to_matrix.pl –est_method sample1.results sample2.results … or 如下./abundance_estimates_to_matrix.pl –est_method –quant_files file.listing_target_files.txt Note, if only a single input file is given, it’s expected to contain the paths to all the target abundance estimation files. Required:–est_method RSEM|eXpress|kallisto|salmon (needs to know what format to expect)–gene_trans_map the gene-to-transcript mapping file. (if you don’t want gene estimates, indicate ‘none’. Options:–cross_sample_norm TMM|UpperQuartile|none (default: TMM)–name_sample_by_basedir name sample column by dirname instead of filename–basedir_index default(-2)–out_prefix default: value for –est_method–quant_files file containing a list of all the target files. 6. 下游分析 6.1 差异表达分析 run_DE_analysis.pl注意，这一步需要第5步中输出文件*RSEM.isoform.counts.matrix***命令如下： /B313/public_software/trinityrnaseq-Trinity-v2.8.4/Analysis/DifferentialExpression/run_DE_analysis.pl –matrix RSEM.isoform.counts.matrix –method edgeR –output edgeR_results 参数如下： 展开查看 6.2 提取最长链 get_longest_isoform_seq_per_trinity_gene.pl perl /B313/public_software/trinityrnaseq-Trinity-v2.8.4/util/misc/get_longest_isoform_seq_per_trinity_gene.pl Trinity90.fasta &gt; longest_transcript.fasta # 这里输出的是一个排序好的文件，最长链排在最前面，需要使用awk提取一下才是真正的最长链 输出文件：longest_transcript.fasta 坑：这里输入的文件第一行是统计数据，第二行是序列，两列一组，然后由长到短排序，如果要提取某一行序列数据，则设置提取偶数行即可。 6.3 功能注释下载的软件：Trinotate、Trinity、sqlite、NCBI Blast、HMMER、signalP v4、tmhmm v2、RNAMMER 比对数据库：SwissProt、Uniref90、Pfam domains 标准化数据： 123makeblastdb -in uniprot_sprot.fasta -dbtype protmakeblastdb -in uniref90.fasta -dbtype prothmmpress Pfam-A.hmm blast比对（比对的数据库可以换成nr/Uniref90） 12345# search Trinity transcriptsblastx -query Trinity.fasta -db uniprot_sprot.fasta -num_threads 8 -max_target_seqs 1 -outfmt 6 -evalue 1e-5 &gt; blastx.outfmt6# search Transdecoder-predicted proteinsblastp -query transdecoder.pep -db uniprot_sprot.fasta -num_threads 8 -max_target_seqs 1 -outfmt 6 -evalue 1e-5 &gt; blastp.outfmt6 功能域 1hmmscan --cpu 8 --domtblout TrinotatePFAM.out Pfam-A.hmm transdecoder.pep &gt; pfam.log 信号肽 1tmhmm --short &lt; transdecoder.pep &gt; tmhmm.out 识别rRNA 123/TRINOTATE_HOME/util/rnammer_support/RnammerTranscriptome.pl --transcriptome Trinity.fasta --path_to_rnammer /usr/bin/software/rnammer_v1.2/rnammer# 输出：Trinity.fasta.rnammer.gff Tips：功能富集分析工具 7. Load transcripts and coding regions8. Output an Annotation Report 9. 数据可视化（见下一篇）","link":"/2019/10/21/Bioinformatics/无参转录组实测1/"}],"tags":[{"name":"Linux管道符","slug":"Linux管道符","link":"/tags/Linux管道符/"},{"name":"Linux软硬链接","slug":"Linux软硬链接","link":"/tags/Linux软硬链接/"},{"name":"Linux文本操作","slug":"Linux文本操作","link":"/tags/Linux文本操作/"},{"name":"机器学习概览","slug":"机器学习概览","link":"/tags/机器学习概览/"},{"name":"analysis of variance","slug":"analysis-of-variance","link":"/tags/analysis-of-variance/"},{"name":"线性方程组","slug":"线性方程组","link":"/tags/线性方程组/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","link":"/tags/概率论与数理统计/"},{"name":"生活的诗","slug":"生活的诗","link":"/tags/生活的诗/"},{"name":"博客建设","slug":"博客建设","link":"/tags/博客建设/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Try new thing","slug":"Try-new-thing","link":"/tags/Try-new-thing/"},{"name":"electron开发","slug":"electron开发","link":"/tags/electron开发/"},{"name":"js学习","slug":"js学习","link":"/tags/js学习/"},{"name":"转录组","slug":"转录组","link":"/tags/转录组/"},{"name":"python基础","slug":"python基础","link":"/tags/python基础/"},{"name":"数据可视化","slug":"数据可视化","link":"/tags/数据可视化/"},{"name":"seaborn-visualization","slug":"seaborn-visualization","link":"/tags/seaborn-visualization/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/数据结构与算法/"},{"name":"无参转录组实战","slug":"无参转录组实战","link":"/tags/无参转录组实战/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Machinelearning","slug":"Machinelearning","link":"/categories/Machinelearning/"},{"name":"Mathematics","slug":"Mathematics","link":"/categories/Mathematics/"},{"name":"Poetry with Life","slug":"Poetry-with-Life","link":"/categories/Poetry-with-Life/"},{"name":"log","slug":"log","link":"/categories/log/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"Bioinformatics","slug":"Bioinformatics","link":"/categories/Bioinformatics/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/计算机基础/"}]}